.TH "gtc_packing" 3 "Tue Dec 18 2018" "IMAC run" \" -*- nroff -*-
.ad l
.nh
.SH NAME
gtc_packing \- This extension provides a set of function to convert vertors to packed formats\&.  

.SH SYNOPSIS
.br
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "GLM_FUNC_DECL \fBuint8\fP \fBglm::packUnorm1x8\fP (float v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL float \fBglm::unpackUnorm1x8\fP (\fBuint8\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint16\fP \fBglm::packUnorm2x8\fP (\fBvec2\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBvec2\fP \fBglm::unpackUnorm2x8\fP (\fBuint16\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint8\fP \fBglm::packSnorm1x8\fP (float s)"
.br
.ti -1c
.RI "GLM_FUNC_DECL float \fBglm::unpackSnorm1x8\fP (\fBuint8\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint16\fP \fBglm::packSnorm2x8\fP (\fBvec2\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBvec2\fP \fBglm::unpackSnorm2x8\fP (\fBuint16\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint16\fP \fBglm::packUnorm1x16\fP (float v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL float \fBglm::unpackUnorm1x16\fP (\fBuint16\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint64\fP \fBglm::packUnorm4x16\fP (\fBvec4\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBvec4\fP \fBglm::unpackUnorm4x16\fP (\fBuint64\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint16\fP \fBglm::packSnorm1x16\fP (float v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL float \fBglm::unpackSnorm1x16\fP (\fBuint16\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint64\fP \fBglm::packSnorm4x16\fP (\fBvec4\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBvec4\fP \fBglm::unpackSnorm4x16\fP (\fBuint64\fP const &p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint16\fP \fBglm::packHalf1x16\fP (float v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL float \fBglm::unpackHalf1x16\fP (\fBuint16\fP v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint64\fP \fBglm::packHalf4x16\fP (\fBvec4\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBvec4\fP \fBglm::unpackHalf4x16\fP (\fBuint64\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint32\fP \fBglm::packI3x10_1x2\fP (\fBivec4\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBivec4\fP \fBglm::unpackI3x10_1x2\fP (\fBuint32\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint32\fP \fBglm::packU3x10_1x2\fP (\fBuvec4\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuvec4\fP \fBglm::unpackU3x10_1x2\fP (\fBuint32\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint32\fP \fBglm::packSnorm3x10_1x2\fP (\fBvec4\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBvec4\fP \fBglm::unpackSnorm3x10_1x2\fP (\fBuint32\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint32\fP \fBglm::packUnorm3x10_1x2\fP (\fBvec4\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBvec4\fP \fBglm::unpackUnorm3x10_1x2\fP (\fBuint32\fP p)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBuint32\fP \fBglm::packF2x11_1x10\fP (\fBvec3\fP const &v)"
.br
.ti -1c
.RI "GLM_FUNC_DECL \fBvec3\fP \fBglm::unpackF2x11_1x10\fP (\fBuint32\fP p)"
.br
.in -1c
.SH "Detailed Description"
.PP 
This extension provides a set of function to convert vertors to packed formats\&. 

<\fBglm/gtc/packing\&.hpp\fP> need to be included to use these features\&. 
.SH "Function Documentation"
.PP 
.SS "GLM_FUNC_QUALIFIER \fBuint32\fP glm::packF2x11_1x10 (\fBvec3\fP const & v)"
First, converts the first two components of the normalized floating-point value v into 11-bit signless floating-point values\&. Then, converts the third component of the normalized floating-point value v into a 10-bit signless floating-point value\&. Then, the results are packed into the returned 32-bit unsigned integer\&.
.PP
The first vector component specifies the 11 least-significant bits of the result; the last component specifies the 10 most-significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBvec3\fP unpackF2x11_1x10(uint32 const & p) 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint16\fP glm::packHalf1x16 (float v)"
Returns an unsigned integer obtained by converting the components of a floating-point scalar to the 16-bit floating-point representation found in the OpenGL Specification, and then packing this 16-bit value into a 16-bit unsigned integer\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint32\fP \fBpackHalf2x16(vec2 const & v)\fP 
.PP
\fBuint64\fP \fBpackHalf4x16(vec4 const & v)\fP 
.PP
\fCGLSL packHalf2x16 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint64\fP glm::packHalf4x16 (\fBglm::vec4\fP const & v)"
Returns an unsigned integer obtained by converting the components of a four-component floating-point vector to the 16-bit floating-point representation found in the OpenGL Specification, and then packing these four 16-bit values into a 64-bit unsigned integer\&. The first vector component specifies the 16 least-significant bits of the result; the forth component specifies the 16 most-significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint16\fP packHalf1x16(float const & v) 
.PP
\fBuint32\fP \fBpackHalf2x16(vec2 const & v)\fP 
.PP
\fCGLSL packHalf2x16 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint32\fP glm::packI3x10_1x2 (\fBivec4\fP const & v)"
Returns an unsigned integer obtained by converting the components of a four-component signed integer vector to the 10-10-10-2-bit signed integer representation found in the OpenGL Specification, and then packing these four values into a 32-bit unsigned integer\&. The first vector component specifies the 10 least-significant bits of the result; the forth component specifies the 2 most-significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint32\fP packI3x10_1x2(uvec4 const & v) 
.PP
\fBuint32\fP \fBpackSnorm3x10_1x2(vec4 const & v)\fP 
.PP
\fBuint32\fP \fBpackUnorm3x10_1x2(vec4 const & v)\fP 
.PP
\fBivec4\fP unpackI3x10_1x2(uint32 const & p) 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint16\fP glm::packSnorm1x16 (float v)"
First, converts the normalized floating-point value v into 16-bit integer value\&. Then, the results are packed into the returned 16-bit unsigned integer\&.
.PP
The conversion to fixed point is done as follows: packSnorm1x8: round(clamp(s, -1, +1) * 32767\&.0)
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint32\fP \fBpackSnorm2x16(vec2 const & v)\fP 
.PP
\fBuint64\fP \fBpackSnorm4x16(vec4 const & v)\fP 
.PP
\fCGLSL packSnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint8\fP glm::packSnorm1x8 (float s)"
First, converts the normalized floating-point value v into 8-bit integer value\&. Then, the results are packed into the returned 8-bit unsigned integer\&.
.PP
The conversion to fixed point is done as follows: packSnorm1x8: round(clamp(s, -1, +1) * 127\&.0)
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint16\fP \fBpackSnorm2x8(vec2 const & v)\fP 
.PP
\fBuint32\fP \fBpackSnorm4x8(vec4 const & v)\fP 
.PP
\fCGLSL packSnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint16\fP glm::packSnorm2x8 (\fBvec2\fP const & v)"
First, converts each component of the normalized floating-point value v into 8-bit integer values\&. Then, the results are packed into the returned 16-bit unsigned integer\&.
.PP
The conversion for component c of v to fixed point is done as follows: packSnorm2x8: round(clamp(c, -1, +1) * 127\&.0)
.PP
The first component of the vector will be written to the least significant bits of the output; the last component will be written to the most significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint8\fP packSnorm1x8(float const & v) 
.PP
\fBuint32\fP \fBpackSnorm4x8(vec4 const & v)\fP 
.PP
\fCGLSL packSnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint32\fP glm::packSnorm3x10_1x2 (\fBvec4\fP const & v)"
First, converts the first three components of the normalized floating-point value v into 10-bit signed integer values\&. Then, converts the forth component of the normalized floating-point value v into 2-bit signed integer values\&. Then, the results are packed into the returned 32-bit unsigned integer\&.
.PP
The conversion for component c of v to fixed point is done as follows: packSnorm3x10_1x2(xyz): round(clamp(c, -1, +1) * 511\&.0) packSnorm3x10_1x2(w): round(clamp(c, -1, +1) * 1\&.0)
.PP
The first vector component specifies the 10 least-significant bits of the result; the forth component specifies the 2 most-significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBvec4\fP unpackSnorm3x10_1x2(uint32 const & p) 
.PP
\fBuint32\fP \fBpackUnorm3x10_1x2(vec4 const & v)\fP 
.PP
\fBuint32\fP \fBpackU3x10_1x2(uvec4 const & v)\fP 
.PP
\fBuint32\fP \fBpackI3x10_1x2(ivec4 const & v)\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint64\fP glm::packSnorm4x16 (\fBvec4\fP const & v)"
First, converts each component of the normalized floating-point value v into 16-bit integer values\&. Then, the results are packed into the returned 64-bit unsigned integer\&.
.PP
The conversion for component c of v to fixed point is done as follows: packSnorm2x8: round(clamp(c, -1, +1) * 32767\&.0)
.PP
The first component of the vector will be written to the least significant bits of the output; the last component will be written to the most significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint16\fP packSnorm1x16(float const & v) 
.PP
\fBuint32\fP \fBpackSnorm2x16(vec2 const & v)\fP 
.PP
\fCGLSL packSnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint32\fP glm::packU3x10_1x2 (\fBuvec4\fP const & v)"
Returns an unsigned integer obtained by converting the components of a four-component unsigned integer vector to the 10-10-10-2-bit unsigned integer representation found in the OpenGL Specification, and then packing these four values into a 32-bit unsigned integer\&. The first vector component specifies the 10 least-significant bits of the result; the forth component specifies the 2 most-significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint32\fP \fBpackI3x10_1x2(ivec4 const & v)\fP 
.PP
\fBuint32\fP \fBpackSnorm3x10_1x2(vec4 const & v)\fP 
.PP
\fBuint32\fP \fBpackUnorm3x10_1x2(vec4 const & v)\fP 
.PP
\fBivec4\fP unpackU3x10_1x2(uint32 const & p) 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint16\fP glm::packUnorm1x16 (float v)"
First, converts the normalized floating-point value v into a 16-bit integer value\&. Then, the results are packed into the returned 16-bit unsigned integer\&.
.PP
The conversion for component c of v to fixed point is done as follows: packUnorm1x16: round(clamp(c, 0, +1) * 65535\&.0)
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint16\fP packSnorm1x16(float const & v) 
.PP
\fBuint64\fP \fBpackSnorm4x16(vec4 const & v)\fP 
.PP
\fCGLSL packUnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint8\fP glm::packUnorm1x8 (float v)"
First, converts the normalized floating-point value v into a 8-bit integer value\&. Then, the results are packed into the returned 8-bit unsigned integer\&.
.PP
The conversion for component c of v to fixed point is done as follows: packUnorm1x8: round(clamp(c, 0, +1) * 255\&.0)
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint16\fP \fBpackUnorm2x8(vec2 const & v)\fP 
.PP
\fBuint32\fP \fBpackUnorm4x8(vec4 const & v)\fP 
.PP
\fCGLSL packUnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint16\fP glm::packUnorm2x8 (\fBvec2\fP const & v)"
First, converts each component of the normalized floating-point value v into 8-bit integer values\&. Then, the results are packed into the returned 16-bit unsigned integer\&.
.PP
The conversion for component c of v to fixed point is done as follows: packUnorm2x8: round(clamp(c, 0, +1) * 255\&.0)
.PP
The first component of the vector will be written to the least significant bits of the output; the last component will be written to the most significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint8\fP packUnorm1x8(float const & v) 
.PP
\fBuint32\fP \fBpackUnorm4x8(vec4 const & v)\fP 
.PP
\fCGLSL packUnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint32\fP glm::packUnorm3x10_1x2 (\fBvec4\fP const & v)"
First, converts the first three components of the normalized floating-point value v into 10-bit unsigned integer values\&. Then, converts the forth component of the normalized floating-point value v into 2-bit signed uninteger values\&. Then, the results are packed into the returned 32-bit unsigned integer\&.
.PP
The conversion for component c of v to fixed point is done as follows: packUnorm3x10_1x2(xyz): round(clamp(c, 0, +1) * 1023\&.0) packUnorm3x10_1x2(w): round(clamp(c, 0, +1) * 3\&.0)
.PP
The first vector component specifies the 10 least-significant bits of the result; the forth component specifies the 2 most-significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBvec4\fP unpackUnorm3x10_1x2(uint32 const & p) 
.PP
\fBuint32\fP \fBpackUnorm3x10_1x2(vec4 const & v)\fP 
.PP
\fBuint32\fP \fBpackU3x10_1x2(uvec4 const & v)\fP 
.PP
\fBuint32\fP \fBpackI3x10_1x2(ivec4 const & v)\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuint64\fP glm::packUnorm4x16 (\fBvec4\fP const & v)"
First, converts each component of the normalized floating-point value v into 16-bit integer values\&. Then, the results are packed into the returned 64-bit unsigned integer\&.
.PP
The conversion for component c of v to fixed point is done as follows: packUnorm4x16: round(clamp(c, 0, +1) * 65535\&.0)
.PP
The first component of the vector will be written to the least significant bits of the output; the last component will be written to the most significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint16\fP packUnorm1x16(float const & v) 
.PP
\fBuint32\fP \fBpackUnorm2x16(vec2 const & v)\fP 
.PP
\fCGLSL packUnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBvec3\fP glm::unpackF2x11_1x10 (\fBuint32\fP p)"
First, unpacks a single 32-bit unsigned integer p into two 11-bit signless floating-point values and one 10-bit signless floating-point value \&. Then, each component is converted to a normalized floating-point value to generate the returned three-component vector\&.
.PP
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint32\fP \fBpackF2x11_1x10(vec3 const & v)\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER float glm::unpackHalf1x16 (\fBuint16\fP v)"
Returns a floating-point scalar with components obtained by unpacking a 16-bit unsigned integer into a 16-bit value, interpreted as a 16-bit floating-point number according to the OpenGL Specification, and converting it to 32-bit floating-point values\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBvec2\fP \fBunpackHalf2x16(uint32 const & v)\fP 
.PP
\fBvec4\fP unpackHalf4x16(uint64 const & v) 
.PP
\fCGLSL unpackHalf2x16 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBglm::vec4\fP glm::unpackHalf4x16 (\fBuint64\fP p)"
Returns a four-component floating-point vector with components obtained by unpacking a 64-bit unsigned integer into four 16-bit values, interpreting those values as 16-bit floating-point numbers according to the OpenGL Specification, and converting them to 32-bit floating-point values\&. The first component of the vector is obtained from the 16 least-significant bits of v; the forth component is obtained from the 16 most-significant bits of v\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
float unpackHalf1x16(uint16 const & v) 
.PP
\fBvec2\fP \fBunpackHalf2x16(uint32 const & v)\fP 
.PP
\fCGLSL unpackHalf2x16 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBivec4\fP glm::unpackI3x10_1x2 (\fBuint32\fP p)"
Unpacks a single 32-bit unsigned integer p into three 10-bit and one 2-bit signed integers\&.
.PP
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint32\fP \fBpackU3x10_1x2(uvec4 const & v)\fP 
.PP
\fBvec4\fP unpackSnorm3x10_1x2(uint32 const & p); 
.PP
\fBuvec4\fP unpackI3x10_1x2(uint32 const & p); 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER float glm::unpackSnorm1x16 (\fBuint16\fP p)"
First, unpacks a single 16-bit unsigned integer p into a single 16-bit signed integers\&. Then, each component is converted to a normalized floating-point value to generate the returned scalar\&.
.PP
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackSnorm1x16: clamp(f / 32767\&.0, -1, +1)
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBvec2\fP unpackSnorm2x16(uint32 p) 
.PP
\fBvec4\fP unpackSnorm4x16(uint64 p) 
.PP
\fCGLSL unpackSnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER float glm::unpackSnorm1x8 (\fBuint8\fP p)"
First, unpacks a single 8-bit unsigned integer p into a single 8-bit signed integers\&. Then, the value is converted to a normalized floating-point value to generate the returned scalar\&.
.PP
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackSnorm1x8: clamp(f / 127\&.0, -1, +1)
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBvec2\fP \fBunpackSnorm2x8(uint16 p)\fP 
.PP
\fBvec4\fP unpackSnorm4x8(uint32 p) 
.PP
\fCGLSL unpackSnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBvec2\fP glm::unpackSnorm2x8 (\fBuint16\fP p)"
First, unpacks a single 16-bit unsigned integer p into a pair of 8-bit signed integers\&. Then, each component is converted to a normalized floating-point value to generate the returned two-component vector\&.
.PP
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackSnorm2x8: clamp(f / 127\&.0, -1, +1)
.PP
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
float \fBunpackSnorm1x8(uint8 p)\fP 
.PP
\fBvec4\fP unpackSnorm4x8(uint32 p) 
.PP
\fCGLSL unpackSnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBvec4\fP glm::unpackSnorm3x10_1x2 (\fBuint32\fP p)"
First, unpacks a single 32-bit unsigned integer p into four 16-bit signed integers\&. Then, each component is converted to a normalized floating-point value to generate the returned four-component vector\&.
.PP
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackSnorm3x10_1x2(xyz): clamp(f / 511\&.0, -1, +1) unpackSnorm3x10_1x2(w): clamp(f / 511\&.0, -1, +1)
.PP
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint32\fP \fBpackSnorm3x10_1x2(vec4 const & v)\fP 
.PP
\fBvec4\fP unpackUnorm3x10_1x2(uint32 const & p)) 
.PP
\fBuvec4\fP unpackI3x10_1x2(uint32 const & p) 
.PP
\fBuvec4\fP unpackU3x10_1x2(uint32 const & p) 
.RE
.PP

.SS "GLM_FUNC_DECL \fBvec4\fP glm::unpackSnorm4x16 (\fBuint64\fP const & p)"
First, unpacks a single 64-bit unsigned integer p into four 16-bit signed integers\&. Then, each component is converted to a normalized floating-point value to generate the returned four-component vector\&.
.PP
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackSnorm4x16: clamp(f / 32767\&.0, -1, +1)
.PP
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
float \fBunpackSnorm1x16(uint16 p)\fP 
.PP
\fBvec2\fP unpackSnorm2x16(uint32 p) 
.PP
\fCGLSL unpackSnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBuvec4\fP glm::unpackU3x10_1x2 (\fBuint32\fP p)"
Unpacks a single 32-bit unsigned integer p into three 10-bit and one 2-bit unsigned integers\&.
.PP
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint32\fP \fBpackU3x10_1x2(uvec4 const & v)\fP 
.PP
\fBvec4\fP unpackSnorm3x10_1x2(uint32 const & p); 
.PP
\fBuvec4\fP unpackI3x10_1x2(uint32 const & p); 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER float glm::unpackUnorm1x16 (\fBuint16\fP p)"
First, unpacks a single 16-bit unsigned integer p into a of 16-bit unsigned integers\&. Then, the value is converted to a normalized floating-point value to generate the returned scalar\&.
.PP
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackUnorm1x16: f / 65535\&.0
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBvec2\fP unpackUnorm2x16(uint32 p) 
.PP
\fBvec4\fP \fBunpackUnorm4x16(uint64 p)\fP 
.PP
\fCGLSL unpackUnorm2x16 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER float glm::unpackUnorm1x8 (\fBuint8\fP p)"
Convert a single 8-bit integer to a normalized floating-point value\&.
.PP
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackUnorm4x8: f / 255\&.0
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBvec2\fP \fBunpackUnorm2x8(uint16 p)\fP 
.PP
\fBvec4\fP unpackUnorm4x8(uint32 p) 
.PP
\fCGLSL unpackUnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBvec2\fP glm::unpackUnorm2x8 (\fBuint16\fP p)"
First, unpacks a single 16-bit unsigned integer p into a pair of 8-bit unsigned integers\&. Then, each component is converted to a normalized floating-point value to generate the returned two-component vector\&.
.PP
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackUnorm4x8: f / 255\&.0
.PP
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
float \fBunpackUnorm1x8(uint8 v)\fP 
.PP
\fBvec4\fP unpackUnorm4x8(uint32 p) 
.PP
\fCGLSL unpackUnorm4x8 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBvec4\fP glm::unpackUnorm3x10_1x2 (\fBuint32\fP p)"
First, unpacks a single 32-bit unsigned integer p into four 16-bit signed integers\&. Then, each component is converted to a normalized floating-point value to generate the returned four-component vector\&.
.PP
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackSnorm3x10_1x2(xyz): clamp(f / 1023\&.0, 0, +1) unpackSnorm3x10_1x2(w): clamp(f / 3\&.0, 0, +1)
.PP
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
\fBuint32\fP \fBpackSnorm3x10_1x2(vec4 const & v)\fP 
.PP
\fBvec4\fP unpackInorm3x10_1x2(uint32 const & p)) 
.PP
\fBuvec4\fP unpackI3x10_1x2(uint32 const & p) 
.PP
\fBuvec4\fP unpackU3x10_1x2(uint32 const & p) 
.RE
.PP

.SS "GLM_FUNC_QUALIFIER \fBvec4\fP glm::unpackUnorm4x16 (\fBuint64\fP p)"
First, unpacks a single 64-bit unsigned integer p into four 16-bit unsigned integers\&. Then, each component is converted to a normalized floating-point value to generate the returned four-component vector\&.
.PP
The conversion for unpacked fixed-point value f to floating point is done as follows: unpackUnormx4x16: f / 65535\&.0
.PP
The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits\&.
.PP
\fBSee also:\fP
.RS 4
\fBGLM_GTC_packing\fP 
.PP
float \fBunpackUnorm1x16(uint16 p)\fP 
.PP
\fBvec2\fP unpackUnorm2x16(uint32 p) 
.PP
\fCGLSL unpackUnorm2x16 man page\fP 
.PP
\fCGLSL 4\&.20\&.8 specification, section 8\&.4 Floating-Point Pack and Unpack Functions\fP 
.RE
.PP

.SH "Author"
.PP 
Generated automatically by Doxygen for IMAC run from the source code\&.
